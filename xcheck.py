"""XCheck
XMLChecker that doesn't need a separate validator
Just to see if I can do it.

Derive Checkers from XCheck
customize the checkContent function

"""
from elementtree import ElementTree as ET

try:
    from decimal import Decimal
    Inf = Decimal("Infinity")
    NInf = Decimal("-Infinity")
except:
    from infinity import *
    Inf = InfinityPlus()
    NInf = InfinityMinus()
    del infinity

_notesOnErrors="""Error Notes:
Errors should be called as appropriate to python.
IntCheck('a') should raise a ValueError, not an XCheck-based error
IntCheck(1) should rase an IntegerOutOfBounds error if appropriate
(IntegerOutOfBounds is the default IntCheck Error)
"""
class XCheckError(Exception): pass

class MismatchedTagError(XCheckError): pass

class UnknownAttributeError(XCheckError): pass
class AttributeError(XCheckError):pass
class UncheckedAttributeError(XCheckError): pass

class MissingChildError(XCheckError): pass
class UnexpectedChildError(XCheckError): pass

class XCheck(object):
    """XCheck
    Generic validator tool for XML nodes and XML formatted text.
    General Attributes:
        name -- the name used for the XML tag
        minOccurs [default 1] -- the minimum number of times the element must appear
        maxoccures [default 1] -- the maximum number of times the element can appear
        children -- a list of XCheck objects in expected order (XCheck doesn't accept unordered children)
            see addchild for more information

    XML-attribute related attributes:
        unique [default False] -- if the attribute has to be unique (see docs)
        required [default True] -- if the attribute must appear in the element
        attributes -- a dictionary.
            see addattribute for more information

    Miscellaneous Attributes:
        error -- The basic error generated by the checker (see docs)
        checkChildren [default True] -- the flag that checks children of the element
        ordered [default True] -- the flag that determines if the children are ordered or not

    Methods (see individual methods for more information):
        addchild -- adds one or more children to the checker
        addchildren -- synonym for addchild
        addattribute -- adds one or more attributes to the checker
        addattributes -- synonym for addattribute
        checkContent -- method that checks the content of the xml element or data. See docs.

    Calling an XCheck object performs the check.
    XCheck objects will accept an element.tree based element, a string of text
    """
    def __init__(self, name, **kwargs):
        self._name = name    # required
        self.minOccurs = 1  # number of times the element
        self.maxOccurs = 1  # can appear in the parent (if any)
        self.children = []

        #XML attribute related
        self.unique = False
        self.required = True
        self.attributes = {}

        #Miscellaneous attributes
        self.error = XCheckError
        self.checkChildren = True
        self.ordered = True

        # Safely populate the attributes
        for key, val in kwargs.pop('attributes', {}).items():
            if not isinstance(val, XCheck):
                raise AttributeError, 'cannot use %s as attribute checker' % val
            if key != val.name:
                raise AttributeError, 'attribute key and check object name different'
            self._addattribute(val)

        # Safely populate children
        for child in kwargs.pop('children',[]):
            self._addchild(child)
        self.__dict__.update(**kwargs)

    @property
    def name(self):
        return self._name
    
    @property
    def haschildren(self):
        return not self.children == []
    
    @property
    def hasattributes(self):
        return not self.attributes == {}

    def __repr__(self):
        return "<%sCheck object at 0x%x>" % (self.name, id(self))

    def _addchild(self, child):
        if not isinstance(child, XCheck):
            raise self.error, "Cannot use %s as child checker" % child
        self.children.append(child)

    def addchild(self, *children):
        """addchild(*children) [also addchildren]
        add a list of child objects to the expected children
        raises an error if any child object is not an instance of
          an XCheck class
        If passing a list, unpack it:
        >>>x = XCheck('test')
        >>>kids = [XCheck('a'), XCheck('b'), XCheck('c')]
        >>>x.addchildren(*kids)
        """
        for child in children:
            self._addchild(child)

    addchildren = addchild

    def _addattribute(self, att):
        if not isinstance(att, XCheck):
            raise AttributeError, "Cannot use %s as attribute checker" % att
        if att.name in self.attributes:
            raise AttributeError, "Cannot replace known attribute"
        self.attributes[att.name] = att

    def addattribute(self, *atts):
        """addattribute(*atts) [also addattributes]
        add an attribute checker to the element
        Raises an error if any attribute is not an instance of
            an XCheck class
        If passing a list, unpack it:
        >>>x = XCheck('test')
        >>>atts = [XCheck('a'), XCheck('b')]
        >>>x.addattributes(*atts)
        """
        for att in atts:
            self._addattribute(att)

    addattributes = addattribute

    def checkContent(self, item):
        """checkContent(item) -> Bool
        This is the method to customize for your own checker
        """
        #~ raise self.error, "Do not call XCheck on its own"
        return True

    def normalizeContent(self, item):
        """normalizeContent(item)
        This is the method used to normalize the return value.
        normalization is optional
        """
        self._normalizedValue = item

    def __call__(self, arg, checkChildren = None, _normalize = False):
        # Temporarily override the checkChildren attribute
        _cc = None
        #self._normalizedResult = None
        if checkChildren is not None:
            _cc = self.checkChildren
            self.checkChildren = checkChildren

        # Create an element if possible
        elem = None
        if ET.iselement(arg):
            #print "checking", arg.text.strip()
            elem = arg
        if elem is None:
            try:
                elem = ET.fromstring(arg)
            except:
                pass

        #print "element:", elem
        # validate element if appropriate
        if elem is not None:
            ok = elem.tag == self.name
            if not ok:
                raise MismatchedTagError, "Element tag does not match check name"
            content = elem.text
            if content:
                ok &= self.checkContent(content.strip())
            #~ Check the attributes
            atts = dict(self.attributes) # create a copy to play with
            #print "xcheck.attributes", atts
            #print "element.attributes", elem.attrib
            for key, val in elem.items():
                ch = atts.pop(key, None)
                #! element has attribute that the checker doesn't know about
                if ch is None:
                    raise UnknownAttributeError, "Cannot check %s attribute" % key
                #~ check the attribute with the checker
                ok &= ch(val)

            #~ check for leftover required attributes
            for att in atts.values():
                if att.required:
                    raise UncheckedAttributeError, "missing required attribute (%s)" % att.name


            if self.checkChildren:
                if self.ordered:
                    if elem.tag == self.name:
                        self.checkContent(elem.text)
                        
                        if self.haschildren:
                            children = iter(self.children)
                            child = children.next()
                            count = 0
                            for e in elem:
                                if child.name ==  e.tag:
                                    child(e)
                                    count += 1
                                else:
                                    while child.name != e.tag:
                                        if count < child.minOccurs :
                                            raise MissingChildError, "Not enough %s children" % child.name
                                        if count > child.maxOccurs:
                                            raise UnexpectedChildError, "Too many %s children" % child.name
                                        try:
                                            child = children.next()
                                            count = 0
                                        except StopIteration:
                                            raise UnexpectedChildError, "what is %s and what is it doing here?" % child.name
                                    child(e)
                                    count += 1
            
                            if count < child.minOccurs:
                                raise MissingChildError, "Not enough %s children" % child.name
                            if count > child.maxOccurs:
                                raise UnexpectedChildError, "Too many %s children" % child.name
                            
                            # AFTER CHECKING ALL ELEMENTS
                            while True:
                                try:
                                    child = children.next()
                                    if child.minOccurs > 0:
                                        raise MissingChildError, "Missing %s child" % child.name
                                except StopIteration:
                                    break

                            return True
                        # checker has no children
                        else:
                            if len(elem) > 0:
                                raise UnexpectedChildError, "Found child where none expected"
                    else:
                        raise xc.MismatchedTagError, "checker and element don't match"
                #~  UNORDERED SEARCHING
                else:
                    #~ print "unordered search"
                    #~ check that all the elements are expected
                    names = [x.name for x in self.children]
                    #~ print names
                    for e in list(elem):
                        #~ print "%s in names" % e.tag, e.tag in names
                        if e.tag not in names:
                            raise UnexpectedChildError, "Unexpected %s element" % e.tag
                    
                    # assuming that's good, do the checks and counting
                    for child in self.children:
                        count = 0
                        #~ print "checking child", child.name
                        for e in elem.findall(child.name):
                            child(e)
                            count += 1
                        #~ print "found %d %s" % (count, child.name)
                        if count < child.minOccurs:
                            raise MissingChildError, "Not enough %s children" % child.name
                        if count > child.maxOccurs:
                            raise UnexpectedChildError, "Too many %s children" % child.name
        else:
            ok = self.checkContent(arg)

        #~ restore saved checkChildren value
        if _cc is not None:
            self.checkChildren = _cc

        if _normalize:
            if not hasattr(self, '_normalizedValue'):
                raise self.error, "no normalized value"
            else:
                return self._normalizedValue
        else:
            return ok

        
import re

class TextCheck(XCheck):
    """TextCheck(name, **kwargs)
    TextCheck validates text or elements with string values
    
    Attributes:
    minLength [default 0] -- the minimum length of the text
    maxLength [default Inf] -- the maximum length allowed
    pattern [default None] -- a regular expression that can
        be used to check the data.
    """
    def __init__(self, name, **kwargs):
        self.minLength = 0
        self.maxLength = Inf
        self.pattern = None
        XCheck.__init__(self, name, **kwargs)

    def checkContent(self, item):
        ok = isinstance(item, basestring)
        if item is None:
            raise self.error, "Expected some text"
        if  len(item) < self.minLength:
            ok = False
            raise self.error, "Text too short"
        if len(item) > self.maxLength:
            ok = False
            raise self.error, "Text too long"
        if self.pattern is not None:
            if not bool(re.match( self.pattern, item) ):
                ok = False
                raise self.error, "Text failed to match pattern"
        
        if item is None:
            raise self.error, 'Generic text error'
        self.normalizeContent(item)
        
        return ok
    

class EmailCheck(TextCheck):
    """EmailCheck(name, **kwargs)
    Creates a checker specializing in email addresses

    Attributes:
    allowNone [default True] -- allows NoneType or case-insensitive 'none' instead
        of email address
    allowBlank [default False] -- allows an empty or blank string instead of an email
        address
    """
    _emailMatch = re.compile(r'\S+@\S+\.\S+')

    def __init__(self, name, **kwargs):
        self.allowNone = kwargs.pop('allowNone', True)
        self.allowBlank = kwargs.pop('allowBlank', False)

        TextCheck.__init__(self, name, **kwargs)
        self.pattern = r'\S+@\S\.\S'

    def checkContent(self, item):
        ok = None
        if item in [None, 'None', 'none']:
            if self.allowNone:
                ok = True
            else:
                raise self.error, "None not allowed as email"
                ok = False
        
        if ok is None:
            if not item.strip():
                if self.allowBlank:
                    ok = True
                else:
                    ok = False
                    raise self.error, "Blank email not allowed"
        
        if ok is None:
            if  self._emailMatch.match( item) :
                ok = True
            else:
                ok = False
                raise self.error, "%sCheck failed to match %s" % (self.name, item)
        if ok:
            self.normalizeContent(item)
            
        return ok
    
    def normalizeContent(self, item):
        self._normalizedValue=  str(item)

class BoolCheck(XCheck):
    """BoolCheck(name, **kwargs)
    Checks a various number of things that could be interpreted as True.
    These check as True:
        True, true, 1, Yes, yes, T, t, Y, y
    These check as False:
        False, false, 0, No, no, N, n, F, f
    
    Attributes:
    noneIsFalse [default True] -- allows None or NoneType to be 
    accepted for False.
    
    Returns a boolean value if normalized.
    """
    def __init__(self, name, **kwargs):
        self.noneIsFalse = kwargs.pop('noneIsFalse', True)
        XCheck.__init__(self, name, **kwargs)

    def checkContent(self, item):
        ok = None
        if str(item).lower() in ['true','yes','1','t','y']:
            ok = True
            self.normalizeContent(True)
        if str(item).lower() in ['false', 'no', '0', 'f', 'n']:
            ok = True
            self.normalizeContent(False)

        if item is None or str(item).lower().strip() == 'none':
            if self.noneIsFalse:
                ok = True
                self.normalizeContent(False)
            else:
                ok = False
                raise self.error, "BoolCheck cannot accept None"
        if ok is None:
            ok = False
            raise self.error, "Boolean checker cannot check %s" % item
        return ok

    #~ this is a dummy example.
    #~ def normalizeContent(self, item):
        #~ if str(item).lower() in ['true', 'yes', '1', 't', 'y']:
            #~ self._normalizedValue = True
        #~ if str(item).lower() in ['false', 'no', '0', 'f', 'n']:
            #~ self._normalizedValue = False

class NoSelectionError(XCheckError): pass
class BadSelectionsError(XCheckError): pass

class SelectionCheck(XCheck):
    """SelectionCheck(name, **kwargs)
    SelectionCheck checks against a set number of string values
    values -- a required list of string objects
    ignoreCase [default True] -- allows value to match upper or lower case
    """
    _boolCheck = BoolCheck('caseSensitive')
    def __init__(self, name, **kwargs):
        try:
            self.values =list(kwargs.pop('values',[]))
        except:
            raise BadSelectionsError, "Selection must be iterable"

        self.ignoreCase = self._boolCheck( kwargs.pop('ignoreCase',True) , _normalize=True)

        XCheck.__init__(self, name, **kwargs)

        if not self.values:
            raise NoSelectionError, "must have values for selection test"
        for v in self.values:
            if not isinstance(v, basestring):
                raise BadSelectionsError, "Selection value %s is not string type" % v

    def checkContent(self, item):
        ok = None
        item = str(item)
        vals = list(self.values)
        if self.ignoreCase:
            item = item.lower()
            vals = map(str.lower, vals)
        if item not in vals:
            ok = False
            raise self.error, "Selection not in list of available values"
        else:
            ok = True
        return ok

class IntegerOutOfBoundsError(XCheckError): pass
class IntCheck(XCheck):
    def __init__(self, name, **kwargs):
        self.min = NInf
        self.max = Inf
        self.error = IntegerOutOfBoundsError
        XCheck.__init__(self, name, **kwargs)

    def checkContent(self, item):
        ok = None
        try:
            data = int(item)
        except:
            ok = False
            raise ValueError, "item not an integer"
        if float(item) != int(item):
            ok = False
            raise TypeError, "cannot convert float"

        if ok is not None:
            return ok
        ok = True
        ok &= (self.min <= data <= self.max)
        if not ok:
            raise self.error, "item out of bounds"
        return ok

class ListCheck(XCheck):
    """ListCheck(name, **kwargs)
    List Check accepts a string that is formatted as a list

    Attributes:
    delimiter [default ','] -- The separator between items
    values [default []] -- The acceptable values for each item
        if values exists, each item in the list will be checked that it exists in the list
    allowDuplicates [default False] -- if True, items can appear more than once in
        the list. If false, items can only appear once
    minItems [default 0] -- the minimum number of items allowed in the list
    maxItems [default Inf] -- the maximum number if items allowed in the list
    ignoreCase [default False] -- if True, check is not case-sensitive

    """
    _boolCheck = BoolCheck('ignoreCase')
    def __init__(self, name, **kwargs):
        self.delimiter = kwargs.pop('delimiter', ',')
        self.values = kwargs.pop('values', [])
        self.allowDuplicates = kwargs.pop('allowDuplicates', False)
        self.minItems = int(kwargs.pop('minItems', 0) )
        self.maxItems = int(kwargs.pop('maxItems', -1) )
        self.ignoreCase = self._boolCheck(kwargs.pop('ignoreCase', False), _normalize=True)

        if self.maxItems == -1:
            self.maxItems = Inf

        XCheck.__init__(self, name, **kwargs)

    def checkContent(self, item):
        ok = True
        items = item.split(self.delimiter)
        items = map(str.strip, items)
        if self.minItems > len(items):
            ok = False
            raise self.error, "not enough items in the list"
        if self.maxItems < len(items):
            ok = False
            raise self.error, "too many items in the list"
        if self.ignoreCase:
            vals = map(str.lower, self.values)
            items = map(str.lower, items)
        else:
            vals = list(self.values)
        
        if vals != []:
            for item in items:
                ok &= item in vals
                if item not in vals:
                    raise self.error, "Item %s not in values list" % item
                if not self.allowDuplicates:
                    try:
                        vals.remove(item)
                    except ValueError:
                        raise self.error, "Item %s not in values list" % item

        if not ok:
            raise self.error, "sommat got borked"
        return ok


import datetime
import time
class DateTimeCheck(XCheck):
    """DateTimeCheck(name, **kwargs)
    Checks date and time formatted strings, date objects, and time objects.
    Attributes:
    allowNone [default False] -- allows NoneType or equivalent string
    format [default "%a %b %d %H:%M:%S %Y"] -- the format to use while checking
    formats or formatList [default an empty list] -- several string formats
    minDateTime [default datetime.datetime.min (year is 1900)] -- minimum date
    maxDateTime [default datetime.date.max] -- maximum date
    
    Additional attributes in __call__
    _asDateTime [default True] -- normalizes the value to a datetime.datetime object
    _asStruct [default False] -- normalizes the value to a time.struct_time object
    
    DateTimeCheck ignores custom use of _normalize
    """
    _boolCheck=BoolCheck('.')
    def __init__(self, name, **kwargs):
        self.allowNone = self._boolCheck(kwargs.pop('ignoreCase', False), _normalize=True)
        self.format = kwargs.pop('format', "%a %b %d %H:%M:%S %Y")
        self.formats = kwargs.pop('formats',[])
        self.minDT = kwargs.pop('minDateTime', datetime.datetime.min.replace(year=1900))
        self.maxDT = kwargs.pop('maxDateTime', datetime.datetime.max)
        #print self.minDT
        XCheck.__init__(self, name, **kwargs)
        
        if not isinstance(self.minDT, datetime.datetime):
           # print "need to parse minDT", self.minDT, "with", self.format
            try:
                self.minDT = datetime.datetime.strptime(self.minDT, self.format)
            except:
                raise self.error, "cannot parse minimum date"
        if not isinstance(self.maxDT, datetime.datetime):
            try:
                self.maxDT = datetime.datetime.strptime(self.maxDT, self.format)
            except:
                raise self.error, "cannot parse maximum date"
    
    def checkContent(self, item):
        #~ print "checking content", item
        ok = False
        parsedDate = None
        if self.format:
            #~ print "trying  .format", self.format
            try:
                parsedDate = datetime.datetime.strptime(str(item), self.format)
                #~ print tmp
                self._normalizedValue = self.normalizeContent(parsedDate)
                #~ print "normalized:", self._normalizedValue
                ok = True
                #~ print "ok", ok
            except Exception, e:
                pass #print Exception, e
        #~ print "checking ok", ok
        if not ok:
            #~ print "well, that didn't work"
            for format in self.formats:
                #~ print "trying from list", format
                try:
                    parsedDate =datetime.datetime.strptime(str(item), format)
                    self._normalizedValue = self.normalizeContent(parsedDate)
                    ok = True
                    #~ print "Found it"
                    break
                except:
                    pass
        if ok is False:
            raise self.error, "Cannot parse %s as date" % item
        if not (self.minDT <= parsedDate <= self.maxDT):
            raise self.error, "Date out of bounds"
        return ok
    
    def __call__(self, item, **kwargs):
        self._asDateTime = kwargs.pop('_asDateTime', False)
        self._asStruct = kwargs.pop('_asStruct', False)
        #~ print "\ncalling DateTimeCheck"
        #~ print "_asDateTime", self._asDateTime
        #~ print "_asStruct", self._asStruct
        if self._asDateTime or self._asStruct:
            kwargs['_normalize'] = True
        else:
            kwargs['_normalize'] = False
        #~ print kwargs
        return XCheck.__call__(self, item, **kwargs)
    
    def normalizeContent(self, item):
        #print 'normalizing', item
        if self._asDateTime:
            return item #~ should already be a date time object
        elif self._asStruct:
            return item.timetuple() #~ should 
        else:
            if self.format:
                return item.strftime(self.format)
            else:
                return item.strftime(self.formats[0])
        raise ValueError, "cannot normalize %s" % item
        




